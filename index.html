<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간편 한글화 번역기</title>
    <style>
        
        :root, body[data-theme="original-pink"] {
            --bg-main: #f5f7fa;
            --bg-container: rgba(255, 255, 255, 0.95);
            --bg-section: #fafafa;
            --bg-input: #ffffff;
            --bg-success: #e8f5e8;
            --bg-warning: #fff3e0;
            --bg-error: #ffebee;
            --bg-btn-success: #f9f5f7;
            --bg-btn-success-hover: #ece7ec;
            --bg-btn-secondary: rgba(234, 106, 161, 0.95);
            --bg-btn-secondary-hover: #f89fc5;
            --bg-progress-bar: #e0e0e0;
            --bg-progress-fill: #a1ea66;
            --bg-result-stats: #e7f1f6;
            --bg-file-label: #efeded;
            --bg-file-label-hover: #e9ecef;

            --text-title: #2c3e50;
            --text-subtitle: #666;
            --text-section-title: #333;
            --text-label: #555;
            --text-input: #000000;
            --text-btn-primary: #ffffff;
            --text-btn-secondary: #ffffff;
            --text-btn-success: rgb(76, 57, 63);
            --text-status-connected: #2e7d32;
            --text-status-connecting: #f57c00;
            --text-status-disconnected: #c62828;
            --text-file-label: #495057;
            --text-file-label-hover: #4f8ee6;
            
            --border-main: #e0e0e0;
            --border-input: #ddd;
            --border-focus: #ea66b7; 
            --border-section-title-accent: #8566ea;
            --border-success: #c8e6c9;
            --border-warning: #ffcc02;
            --border-error: #ffcdd2;
            --border-btn-success: #ecc5d2d3;
            --border-result-stats: #66bcea;
            --border-file-label: #d6cfd3;
            --border-file-label-hover: #4f8ee6;

            --btn-primary-bg: #ea6aa1;
            --btn-primary-hover: #f89fc5;

            --shadow-container: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        body[data-theme="deep-forest"] {
            --bg-main: #111A19;
            --bg-container: rgba(23, 34, 33, 0.95);
            --bg-section: #284139;
            --bg-input: #1a2c2a;
            --bg-success: rgba(128, 144, 118, 0.2);
            --bg-warning: rgba(248, 215, 148, 0.2);
            --bg-error: rgba(184, 104, 48, 0.2);
            --bg-btn-success: #809076;
            --bg-btn-success-hover: #97a88d;
            --bg-btn-secondary: #B86830;
            --bg-btn-secondary-hover: #c6804e;
            --bg-progress-bar: #809076;
            --bg-progress-fill: #F8D794;
            --bg-result-stats: rgba(40, 65, 57, 1);
            --bg-file-label: #284139;
            --bg-file-label-hover: #3a5a51;

            --text-title: #F8D794;
            --text-subtitle: #b0c9a2;
            --text-section-title: #f0f0f0;
            --text-label: #d8e8ce;
            --text-input: #e0e0e0;
            --text-btn-primary: #995322;
            --text-btn-secondary: #ffffff;
            --text-btn-success: #ffffff;
            --text-status-connected: #a7f0a7;
            --text-status-connecting: #F8D794;
            --text-status-disconnected: #f0a7a7;
            --text-file-label: #F8D794;
            --text-file-label-hover: #ffffff;
            
            --border-main: #809076;
            --border-input: #809076;
            --border-focus: #F8D794;
            --border-section-title-accent: #F8D794;
            --border-success: #809076;
            --border-warning: #F8D794;
            --border-error: #B86830;
            --border-btn-success: #809076;
            --border-result-stats: #F8D794;
            --border-file-label: #809076;
            --border-file-label-hover: #F8D794;

            --btn-primary-bg: #ffd47d;
            --btn-primary-hover: #f7dfa1;

            --shadow-container: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        body[data-theme="citrus-grove"] {
            --bg-main: #fdfaf4;
            --bg-container: rgba(255, 255, 255, 0.95);
            --bg-section: #fff;
            --bg-input: #ffffff;
            --bg-success: rgba(171, 194, 112, 0.15);
            --bg-warning: rgba(254, 200, 104, 0.15);
            --bg-error: rgba(253, 167, 105, 0.15);
            --bg-btn-success: #f0f5e6;
            --bg-btn-success-hover: #e6edd9;
            --bg-btn-secondary: #ABC270;
            --bg-btn-secondary-hover: #c0d18f;
            --bg-progress-bar: #e0e0e0;
            --bg-progress-fill: #ABC270;
            --bg-result-stats: #fff8ed;
            --bg-file-label: #f0f5e6;
            --bg-file-label-hover: #e6edd9;

            --text-title: #473C33;
            --text-subtitle: #7a6e62;
            --text-section-title: #473C33;
            --text-label: #615347;
            --text-input: #000000;
            --text-btn-primary: #ffffff;
            --text-btn-secondary: #ffffff;
            --text-btn-success: #473C33;
            --text-status-connected: #5d7331;
            --text-status-connecting: #b5893a;
            --text-status-disconnected: #b46d3e;
            --text-file-label: #473C33;
            --text-file-label-hover: #FDA769;
            
            --border-main: #e8e3d8;
            --border-input: #dcd7ce;
            --border-focus: #FDA769;
            --border-section-title-accent: #FEC868;
            --border-success: #d8e0c0;
            --border-warning: #fee8b9;
            --border-error: #fcdbc2;
            --border-btn-success: #d8e0c0;
            --border-result-stats: #FEC868;
            --border-file-label: #d8e0c0;
            --border-file-label-hover: #FDA769;

            --btn-primary-bg: #FDA769;
            --btn-primary-hover: #fdb88c;

            --shadow-container: 0 20px 40px rgba(71, 60, 51, 0.1);
        }

        body[data-theme="modern-slate"] {
            --bg-main: #f4f4f6;
            --bg-container: rgba(255, 255, 255, 0.95);
            --bg-section: #ffffff;
            --bg-input: #ffffff;
            --bg-success: rgba(62, 80, 88, 0.1);
            --bg-warning: rgba(85, 83, 88, 0.1);
            --bg-error: rgba(65, 79, 107, 0.15);
            --bg-btn-success: #f7f6f5;
            --bg-btn-success-hover: #EFEBE4;
            --bg-btn-secondary: #555358;
            --bg-btn-secondary-hover: #6c6a6f;
            --bg-progress-bar: #e0e0e0;
            --bg-progress-fill: #3E5058;
            --bg-result-stats: #f8f9fa;
            --bg-file-label: #f7f6f5;
            --bg-file-label-hover: #EFEBE4;

            --text-title: #3E5058;
            --text-subtitle: #555358;
            --text-section-title: #3E5058;
            --text-label: #555358;
            --text-input: #000000;
            --text-btn-primary: #ffffff;
            --text-btn-secondary: #ffffff;
            --text-btn-success: #3E5058;
            --text-status-connected: #3E5058;
            --text-status-connecting: #555358;
            --text-status-disconnected: #414F6B;
            --text-file-label: #3E5058;
            --text-file-label-hover: #414F6B;
            
            --border-main: #EFEBE4;
            --border-input: #d9d5cf;
            --border-focus: #414F6B;
            --border-section-title-accent: #414F6B;
            --border-success: #bec8cc;
            --border-warning: #c3c2c4;
            --border-error: #b7bfd1;
            --border-btn-success: #d9d5cf;
            --border-result-stats: #414F6B;
            --border-file-label: #d9d5cf;
            --border-file-label-hover: #414F6B;

            --btn-primary-bg: #414F6B;
            --btn-primary-hover: #56688a;

            --shadow-container: 0 20px 40px rgba(85, 83, 88, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 15px;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }
                
        .container {
            position: relative; 
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-container);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 1.8em;
            color: var(--text-title);
            margin-bottom: 8px;
            font-weight: 600;
        }        

        .subtitle {
            color: var(--text-subtitle);
            font-size: 1.1em;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 2px solid var(--border-main);
            border-radius: 15px;
            background: var(--bg-section);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .section-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap; 
            position: relative;
        }
        
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--text-section-title);
            display: flex;
            align-items: center;
        }
        
        .section-title-container .section-title {
            margin-bottom: 0;
        }

        .section-title-last {
            margin-bottom: 0px !important;
        }
        
        .section-title::before {
            content: "";
            width: 4px;
            height: 20px;
            background: var(--border-section-title-accent);
            margin-right: 10px;
            border-radius: 2px;
            transition: background-color 0.3s ease;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .settings-grid-margin {
            margin-bottom: 15px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .char-counter {
            position: absolute;
            bottom: 5px;
            right: 20px;
            font-size: 12px;
            color: var(--text-subtitle);
            background-color: var(--bg-input);
            padding: 2px 6px;
            border-radius: 5px;
            pointer-events: none; /* 마우스 클릭이 카운터 뒤의 텍스트창으로 전달되도록 설정 */
            transition: color 0.3s ease, background-color 0.3s ease;
            opacity: 0.8;
        }
        
        label {
            font-weight: 500;
            margin: 0px 0px 5px 5px;
            color: var(--text-label);
        }

        label-checkbox {
            color: white;
        }
        
        input, select, textarea {
            padding: 12px;
            border: 2px solid var(--border-input);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background-color: var(--bg-input);
            color: var(--text-input);
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        
        .connection-status {
            padding: 8px 12px;
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
            font-size: 13px;
            margin-top: 12px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .status-disconnected {
            background: var(--bg-error);
            color: var(--text-status-disconnected);
            border: 2px solid var(--border-error);
        }
        
        .status-connected {
            background: var(--bg-success);
            color: var(--text-status-connected);
            border: 2px solid var(--border-success);
        }
        
        .status-connecting {
            background: var(--bg-warning);
            color: var(--text-status-connecting);
            border: 2px solid var(--border-warning);
        }
        
        .textarea-large {
            min-height: 200px;
            resize: vertical;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .textarea-medium {
            min-height: 120px;
            resize: vertical;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .textarea-large::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        .textarea-large::-webkit-scrollbar {
            width: 12px;
        }
        .textarea-large::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .textarea-medium::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        .textarea-medium::-webkit-scrollbar {
            width: 12px;
        }
        .textarea-medium::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center; 
        }
                
        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            text-transform: none;
            letter-spacing: 0.3px;
        }

        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.15);
        }

        .btn:hover:before {
            left: 100%;
        }

        .btn-primary {
            background: var(--btn-primary-bg);
            color: var(--text-btn-primary);
            border: none;
        }

        .btn-primary:hover {
            background: var(--btn-primary-hover);
        }

        .btn-secondary {
            background: var(--bg-btn-secondary);
            color: var(--text-btn-secondary);
            border: none;
        }

        .btn-secondary:hover {
            background: var(--bg-btn-secondary-hover);
            opacity: 1;
        }

        .btn-success {
            background: var(--bg-btn-success);
            color: var(--text-btn-success);
            border: 2px solid var(--border-btn-success);
        }

        .btn-success:hover {
            background: var(--bg-btn-success-hover);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 13px;
            margin-left: 2px;
            border-radius: 8px;
            font-weight: 500;
        }

        .btn-small-test {
            min-width: 90px;
        }

        .btn-text-like {
            background: none;
            border: none;
            color: var(--text-subtitle);
            cursor: pointer;
            padding: 0;
            font-size: 13px;
            font-weight: 500;
            margin: 0px 6px 3px 0px;
        }

        .btn-text-like:hover {
            color: var(--text-title);
            text-decoration: underline;
        }

        .inputText-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .api-key-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .api-key-actions #connectionStatus {
            margin-top: 0;
            margin-bottom: 0;
        }

        #apiKey {
            width: 100%;
        }
        
        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .settings-inline {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .input-with-button {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .input-with-button input {
            flex-grow: 1; 
            min-width: 100px;
        }

        .input-with-button .btn {
            flex-shrink: 0;
        }

        .settings-inline-btn {
            margin-top: 15px;
        }
        
        .action-button-container {
            display: flex;
            justify-content: flex-start;
            margin-top: 15px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-progress-bar);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--bg-progress-fill);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        
        .result-stats {
            background: var(--bg-result-stats);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid var(--border-result-stats);
            color: var(--text-label);
        }
        
        .warning {
            background: #fff3cd; 
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .save-load-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-input {
            display: none;
        }
        
        .file-label {
            padding: 8px 15px;
            margin: 0px !important;
            text-align: center;
            background: var(--bg-file-label);
            border: 2px dashed var(--border-file-label);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            color: var(--text-file-label);
        }

        .file-label:hover {
            background: var(--bg-file-label-hover);
            border-color: var(--border-file-label-hover);
            color: var(--text-file-label-hover);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }
        
        .theme-switcher {
            position: absolute;
            top: 30px;  
            right: 30px; 
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .theme-button {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
        }

        .theme-button:hover {
            transform: scale(1.15);
            border-color: rgba(0,0,0,0.3);
        }

        .theme-button.active {
            border: 3px solid var(--border-focus);
            transform: scale(1.1);
        }
        
        .feather {
            width: 1em; 
            height: 1em;
            stroke: currentColor; 
            stroke-width: 2; 
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none; 
            vertical-align: -0.1em; 
        }

        .section-title .feather {
            width: 1.1em; 
            height: 1.1em;
            stroke-width: 2; 
            margin-right: 8px; 
            margin-top: 3px;
            vertical-align: -0.2em;
        }
        
        .btn .feather {
            margin-right: 4px; 
            vertical-align: -0.15em;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column-reverse; 
            gap: 10px; 
            align-items: flex-end; 
        }

        .toast-notification {
            
            width: max-content; 
            max-width: 350px;   
            padding: 15px 25px;
            border-radius: 12px;
            color: var(--text-btn-primary);
            font-size: 15px;
            font-weight: 500;
            opacity: 0;
            transform: translateX(100%); 
            transition: all 0.4s ease-in-out; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0); 
        }

        .toast-notification.success { background-color: var(--btn-primary-bg); }
        .toast-notification.error { background-color: #bf3737; color: #ffffff }
        .toast-notification.info { background-color: var(--bg-btn-secondary); color: var(--text-btn-secondary); }

        
        .btn-log-viewer {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .btn-log-viewer:hover {
            background-color: var(--bg-file-label-hover);
        }
        .btn-log-viewer svg {
            width: 18px;
            height: 18px;
            stroke: var(--text-subtitle);
        }

        .log-popover {
            position: absolute;
            top: 100%;
            right: 0;
            width: 450px;
            max-width: 90vw;
            max-height: 400px;
            z-index: 100;
            margin-top: 8px;

            
            background-color: rgba(28, 28, 30, 0.9);
            color: #f0f0f0;

            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);

            padding: 15px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            
            font-size: 12px; 
            line-height: 1.6;

            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            transform-origin: top right;
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .log-popover::-webkit-scrollbar {
            width: 8px; 
        }

        .log-popover::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05); 
            border-radius: 10px;
        }

        .log-popover::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2); 
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box;
        }

        .log-popover::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.4); 
        }
        
        .log-popover.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .log-popover p {
            margin: 0 0 5px;
            padding: 3px 8px;
            border-radius: 4px;
            word-break: break-all; 
        }

        .footer-info {
            text-align: center;
            padding: 20px 15px;
            color: var(--text-subtitle);
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #update-log-popover {
            position: fixed;
            bottom: 60px; /* 화면 하단으로부터의 거리 */
            left: 50%;   /* 화면 왼쪽에서 50% 지점 */
            top: auto;   /* 기존 top 스타일 초기화 */
            right: auto; /* 기존 right 스타일 초기화 */
            width: 350px;
            transform-origin: bottom center;
            z-index: 1000;
            transform: translateX(-50%) translateY(10px) scale(0.95);
        }

        #update-log-popover.visible {
            transform: translateX(-50%) translateY(0) scale(1);
        }

        #advancedSettingsPanel {
            padding: 15px;
            border: 2px solid var(--border-main);
            border-radius: 10px;
            margin-top: 5px;
            background: var(--bg-main);
        }

        #persistent-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 20px;
            border-radius: 12px;
            color: var(--text-btn-primary);
            background-color: var(--btn-primary-bg);
            font-size: 16px;
            font-weight: 500;
            z-index: 9998;
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
            opacity: 0;
            transition: opacity 0.3s ease, bottom 0.3s ease;
            pointer-events: none;
        }

        #persistent-toast.show {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width: 650px) {
            body {
                padding: 0;
            }
            .container {
                padding: 20px;
                margin: 10px;
                border-radius: 15px;
            }
            .theme-switcher {
                top: 20px; 
                right: 20px;
            }
            .header {
                margin-top: 35px; 
            }
            .title {
                font-size: 1.8em;
            }
            .section {
                padding: 15px;
            }
            .settings-grid {
                grid-template-columns: 1fr;
            }
            .button-group {
                flex-direction: column;
                align-items: stretch;
            }
            .btn {
                width: 100%;
                text-align: center;
            }
            .section-title-container {
                align-items: flex-start;
                gap: 10px;
            }
            .header-buttons {
                width: 100%;
                flex-direction: column;
            }
            .header-buttons .btn {
                margin-left: 0;
            }
            .api-key-actions .btn {
                width: auto;
                flex-shrink: 0;
            }
            .api-key-actions #connectionStatus {
                flex-grow: 1;
                text-align: center;
            }
            .input-with-button {
                flex-direction: column;
                align-items: stretch;
            }
            .input-with-button .btn-small {
                margin-left: 0;
            }
            .textarea-medium {
                min-height: 200px;
            }
            .action-button-container {
                justify-content: stretch;
            }
            .action-button-container .btn {
                 width: 100%;
            }
            .log-popover{
                width: 105%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="theme-switcher">
            <button class="theme-button" data-theme="original-pink" onclick="setTheme(this)" style="background-color: #ea6aa1;" title="Original Pink"></button>
            <button class="theme-button" data-theme="citrus-grove" onclick="setTheme(this)" style="background-color: #FDA769;" title="Citrus Grove"></button>
            <button class="theme-button" data-theme="modern-slate" onclick="setTheme(this)" style="background-color: #414F6B;" title="Modern Slate"></button>
            <button class="theme-button" data-theme="deep-forest" onclick="setTheme(this)" style="background-color: #5d7331;" title="Deep Forest"></button>
        </div>
        <div class="header">
            <h1 class="title">간편 한글화 번역기</h1>
            <p class="subtitle">무단 전재 및 상업적 이용 금지</p>
        </div>
        
        <div class="section">
            <div class="section-title-container">
                <div class="section-title"><i data-feather="settings"></i> API 설정</div>
                <div class="header-buttons">
                    <button class="btn btn-success btn-small" onclick="saveSettings()"><i data-feather="download"></i> 설정 백업</button>
                    <button class="btn btn-success btn-small" onclick="loadSettings()"><i data-feather="log-in"></i> 불러오기</button>
                </div>
            </div>
            <div class="settings-grid">
                <div class="input-group">
                    <label for="sourceLanguage">번역할 언어</label>
                    <select id="sourceLanguage" onchange="updateLanguageLabels(); loadSelectedPrompt();">                    
                        <option value="chinese">🇨🇳 중국어 → 한국어</option>
                        <!-- <option value="english">🇺🇸 영어 → 한국어 (업데이트 예정)</option>
                        <option value="japanese">🇯🇵 일본어 → 한국어 (업데이트 예정)</option>
                        <option value="korean">🇰🇷 한국어 → 외국어 (업데이트 예정)</option> -->
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiProvider">API 제공자</label>
                <select id="apiProvider" onchange="handleProviderChange()">
                        <option value="gemini">Google Gemini</option>
                        <option value="openai">OpenAI</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiModel">모델 선택</label>
                    <select id="apiModel" onchange="handleModelChange(this.value)">
                        <option value="gemini-2.5-pro">gemini-2.5-pro</option>
                        <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                        <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API 키</label>
                    <input type="password" id="apiKey" placeholder="API 키를 입력하세요">
                    <div class="api-key-actions">
                        <button class="btn btn-primary btn-small btn-small-test" onclick="testConnection()"><i data-feather="zap"></i> 테스트</button>
                        <div id="connectionStatus" class="connection-status status-disconnected">연결되지 않음</div>
                    </div>
                </div>
                <div class="input-group" style="grid-column: 1 / -1;">
                    <div class="settings-inline" style="justify-content: space-between; align-items: center; margin-bottom: 10px;">
                         <button class="btn-text-like" onclick="toggleAdvancedSettings()">
                            <i data-feather="sliders"></i> 고급 파라미터 설정
                        </button>
                    </div>
                    <div id="advancedSettingsPanel" style="display: none;">
                        <div class="settings-grid">
                             <div class="input-group">
                                <label for="temperature">온도 (Temperature)</label>
                                <input type="number" id="temperature" step="0.01" min="0" max="2" value="1">
                            </div>
                            <div class="input-group">
                                <label for="maxOutputTokens">최대 출력 토큰</label>
                                <input type="number" id="maxOutputTokens" step="1" min="1" value="65536">
                            </div>
                            <div class="input-group">
                                <label for="topP">Top P</label>
                                <input type="number" id="topP" step="0.01" min="0" max="1" value="0.98">
                            </div>
                            <div class="input-group">
                                <label for="topK">Top K</label>
                                <input type="number" id="topK" step="1" min="0" value="0">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title"><i data-feather="align-left"></i> 번역 프롬프트</div>
            <div class="settings-grid settings-grid-margin">
                <div class="input-group">
                    <label for="promptSelect">저장된 프롬프트</label>
                    <select id="promptSelect" onchange="loadSelectedPrompt()">
                        <option value="default">기본 프롬프트</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="promptName">프롬프트 이름</label>
                    <div class="input-with-button">
                        <input type="text" id="promptName" placeholder="새 프롬프트 이름">
                        <button class="btn btn-secondary btn-small" onclick="savePrompt()" title="프롬프트 저장"><i data-feather="save"></i> 저장</button>
                    </div>
                </div>
            </div>
            <div class="input-group">
                <label for="translationPrompt">번역용 프롬프트</label>
                <textarea id="translationPrompt" class="textarea-medium"></textarea>
            </div>
            <div class="settings-inline settings-inline-btn">
                <button class="btn btn-success btn-small" onclick="resetToDefault()" title="기본값으로 되돌리기"><i data-feather="refresh-ccw"></i> 기본값</button>
                <button class="btn btn-success btn-small" onclick="importPrompt()" title="프롬프트 가져오기"><i data-feather="log-in"></i> 가져오기</button>
                <button class="btn btn-success btn-small" onclick="exportPrompt()" title="프롬프트 내보내기"><i data-feather="log-out"></i> 내보내기</button>
                <button class="btn btn-success btn-small" onclick="deletePrompt()" title="선택된 프롬프트 삭제"><i data-feather="trash"></i> 삭제</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title-container" id="input-text-header">
                <div class="section-title"><i data-feather="type"></i> 입력 텍스트</div>
            </div>
            <div class="input-group">
                <div class="inputText-container">
                    <label for="inputText" id="input-text-label">중국어 → 한국어</label>
                    <button class="btn-text-like" onclick="clearInputText()">비우기</button>
                </div>
                <textarea id="inputText" class="textarea-large" placeholder="텍스트나 코드를 입력하세요..." oninput="handleInputTextChange()"></textarea>
                <div id="inputTextCounter" class="char-counter">0자</div>
            </div>
            <div class="button-group">
                <label for="fileInput" class="file-label"><i data-feather="folder"></i> 파일 선택 (txt, json, jsonl, html, css)</label>
                <input type="file" id="fileInput" class="file-input" accept=".txt,.json,.jsonl,.html,.css" onchange="loadFile()">
                <button class="btn btn-primary" onclick="convertChinesePunctuation()" id="punctuationBtn" style="display: none;"><i data-feather="refresh-ccw"></i> 문장부호 변환 (권장)</button>
                <button class="btn btn-primary" onclick="extractChinese()" id="extractBtn"><i data-feather="mouse-pointer"></i> 중국어 추출</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title" id="extracted-text-title"><i data-feather="file-text"></i> 추출된 텍스트</div>
            <div class="input-group">
                <textarea id="extractedChinese" class="textarea-medium" placeholder="추출된 텍스트가 여기에 표시됩니다..."></textarea>
                <div id="extractedChineseCounter" class="char-counter">0자</div>
            </div>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="action-button-container">
                <button class="btn btn-primary" onclick="translateText()" disabled><i data-feather="mouse-pointer"></i> 번역 실행</button>
            </div>
            <div id="extractStats" class="result-stats" style="display: none;">
                <strong>추출 결과:</strong> <span id="extractCount">0</span>개의 <span id="languageType">중국어</span> 문자열이 발견되었습니다.
            </div>
        </div>
        
        <div class="section">
            <div class="section-title-container" id="translation-result-header">
                <div class="section-title"><i data-feather="edit-3"></i> 번역 결과</div>
            </div>
            <div class="input-group">
                <textarea id="translationResult" class="textarea-medium" placeholder="번역 결과가 여기에 표시됩니다..." oninput="updateReplaceButtonState(); updateTranslationStatsFromTextarea(); toggleSpecialCharCheckButtonVisibility();"></textarea>
                <div id="translationResultCounter" class="char-counter">0자</div>
            </div>
            <div class="action-button-container button-group"> 
                <button class="btn btn-primary" onclick="replaceText()" disabled><i data-feather="mouse-pointer"></i> 일괄 변환</button>
                <button class="btn btn-success btn-small" onclick="importTranslationPairs()"><i data-feather="log-in"></i> 불러오기 (txt, json)</button>
                <button class="btn btn-success btn-small" onclick="exportTranslationPairs()"><i data-feather="log-out"></i> 내보내기 (txt)</button>
                <button class="btn btn-secondary btn-small" onclick="validateSpecialCharacters()" id="validateSpecialCharsBtn" style="display: none;"><i data-feather="check-square"></i> 특수문자 검사</button>
            </div>
            <div id="translationStats" class="result-stats" style="display: none;">
                <strong>번역 결과:</strong> <span id="translationCount">0</span>개의 문자열 쌍이 번역되었습니다.
            </div>
        </div>
        
        <div class="section section-title-last">
            <div class="section-title-container" id="final-text-header"> 
                <div class="section-title"><i data-feather="download"></i> 변환된 최종 텍스트</div>
            </div>
            <div class="input-group">
                
                <textarea id="finalResult" class="textarea-large" placeholder="변환된 최종 결과가 여기에 표시됩니다..." oninput="validateFinalText()"></textarea>
                <div id="translationResultCounter" class="char-counter">0자</div>
            </div>
            
            <div class="button-group">
                <button class="btn btn-success" onclick="copyToClipboard()"><i data-feather="copy"></i> 복사</button>
                <button class="btn btn-secondary" onclick="downloadResult()"><i data-feather="download"></i> 파일로 저장</button>
            </div>
            
            <div id="validationResult" class="result-stats" style="display: none;"></div>
        </div>
    </div>
    <div class="footer-info">
        <span>EasyKr V1.0.2 beta</span>
        <button class="btn-log-viewer" title="업데이트 로그 보기" onclick="toggleUpdateLog(event)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather"><path d="M12 17s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>
        </button>
    </div>

    <div id="update-log-popover" class="log-popover">
        <p style="text-align: center; color: #aaa;">아직 업데이트 로그가 없습니다.</p>
    </div>
    <div id="toast-container"></div>
    <div id="persistent-toast"></div>
    <script src="https://unpkg.com/feather-icons"></script>
    <script>
        let extractedChineseArray = [];
        let currentLogData = [];
        let currentFileName = '';
        let currentFileExtension = '';

        const labels = {
            'chinese': '중국어',
            'english': '영어',
            'japanese': '일본어',
            'korean': '한국어'
        };

        const DEFAULT_PROMPTS = {
            'chinese': '**[CONTEXT]**\nYou are a translation engine for an automated script. Your task is to perform a 1:1 substitution of Chinese text fragments with their Korean translations. The output will be parsed by a script that replaces the original Chinese text with your translation. This script relies on perfect, character-for-character preservation of all non-Chinese elements.\n\n**[ABSOLUTE GOLDEN RULE - THIS OVERRIDES ALL OTHER INSTRUCTIONS]**\n**DO NOT, under any circumstances, modify, \"fix\", or \"correct\" any punctuation, symbols, placeholders, or formatting.** Your primary goal is structural preservation, which is more important than linguistic naturalness. Treat these elements like code that must be copied perfectly.\n\n*   **Punctuation & Symbols:** Chinese punctuation like `。`, `！`, `？`, `：`, `「」` MUST remain identical. **DO NOT change `。` to `.` or `：` to `:`**.\n*   **Formatting & Placeholders:** `\\n`, `%s`, `{0}`, etc., MUST be kept in their exact positions.\n*   **Other Text:** English text, numbers, emojis MUST be left unchanged.\n\n**[OUTPUT FORMAT]**\n*   Return ONLY key-value pairs: `original_chinese=translated_korean`.\n*   One pair per line.\n*   NO headers, explanations, or conversational text. Any extra text will cause a fatal script error.\n\n**[TRANSLATION RULES]**\n1.  **1:1 Line Mapping:** Each input line must correspond to exactly one output line. DO NOT merge or split lines, even if it seems more natural.\n2.  **Contextual Translation:** Use adjacent lines for context to ensure the fragment translation is natural *within its given structure*, but do not alter the structure itself.\n3.  **Consistency:** Translate a specific Chinese term into the same Korean word throughout the request. (e.g., if \"字体\" is \"글꼴\", it must always be \"글꼴\").\n4.  **Glossary:** You MUST use the provided Korean translations for these terms:\n    [--- GLOSSARY ---]\n    prompt → 프롬프트\n    tavern, sillytavern → 실리태번\n    world book, world info → 월드인포\n    character, 角色 → 캐릭터\n    吗(single) → ?\n    [--- END OF GLOSSARY ---]\n5. Proper Nouns: Translate Chinese names phonetically into Korean. You must maintain strict consistency; the same Chinese name must always be translated into the exact same Korean spelling. (e.g., 张伟 → 장웨이)\n\n**[Examples of PERFECT output]**\n*   Example 1 (Punctuation & Fragments):\n    *   Input: `请选择一个 character。\n    *   Correct Output: `请选择一个 character。=`캐릭터를 한 명 선택해 주세요。\n    *   **WRONG Output:** `请选择一个 character。=캐릭터를 한 명 선택해 주세요.` (The \"。\" was incorrectly changed to \".\", and the location of \"`\" is changed)\n\n    *   Input: 请选择一个\\\\n你想去的地方\\\n    *   Correct Output: 请选择一个\\\\n你想去的地方\\=하나를 선택해 주세요\\\\n가고 싶은 장소를\\\n    *   **WRONG Output:** 请选择一个\\n你想去的地方=하나를 선택해 주세요\\n가고 싶은 장소를 (The \"\\\\n\" was not supposed to be fixed)\n\n    *   Input: (仅格式化显示/提示词\n    *   Correct Output: (仅格式化显示/提示词=(서식 지정 표시/프롬프트만\n    *   **WRONG Output:** (仅格式化显示/提示词=(서식 지정 표시/프롬프트만)\n\n*   Example 2 (Placeholder):\n    *   Input: [Error] 无法找到文件 %s\n    *   Correct Output: [Error] 无法找到文件 %s=[Error] 파일을 찾을 수 없습니다 %s\n    *   **WRONG Output:** [Error] 无法找到文件 %s=[Error] 파일을 찾을 수 없습니다. (The \"%s\" was not supposed to be fixed, and \".\" was not supposed to be added)\n\n*   Example 3 (Multi-lines):\n    *   Input:\n    将选中的${n\n    length}条消息移动到哪一楼之前\n    *   Correct Output:\n    将选中的${n=선택한 ${n\n    length}条消息移动到哪一楼之前=length}개의 메시지를 몇 번째 메시지 앞으로 이동하시겠습니까\n\n**주의: `。`, `：` 와 같은 중국어 문장 부호는 절대로 한국어 `.`이나 `:`으로 바꾸지 마세요. 입력에 있는 그대로 출력에 포함해야 합니다. 이 규칙은 번역의 자연스러움보다 중요합니다.**\n\nNow, translate the following Chinese text fragments into Korean, strictly following all the rules above: ',
            'english': 'Please translate the English text fragments into Korean. Keep formatting and return as: original_english=translated_korean',
            'japanese': 'Please translate the Japanese text fragments into Korean. Convert Japanese punctuation to Korean equivalents. Return as: original_japanese=translated_korean',
            'korean': 'Please translate the Korean text fragments into the target foreign language. Return as: original_korean=translated_target'
        };

        const LOW_SPEC_MODELS = {
            // '모델 이름': { maxOutput: 최대출력토큰, safeInputChars: 안전한입력글자수 }
            'gemini-2.0-flash': { maxOutput: 8192, safeInputChars: 25000 },
            'gemini-2.0-flash-001': { maxOutput: 8192, safeInputChars: 25000 },
            'gpt-4o': { maxOutput: 16384, safeInputChars: 25000 },
            'chatgpt-4o-latest': { maxOutput: 16384, safeInputChars: 50000 },
            'gpt-4o-mini': { maxOutput: 16384, safeInputChars: 50000 },
            'gpt-5-chat-latest': { maxOutput: 16384, safeInputChars: 50000 },
        };

        const OPENAI_MODELS_NO_TOP_P = [
            'gpt-5', 'gpt-5-mini', 'gpt-5-chat', 'gpt-5-nano',
            'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano'
        ];

        const DEFAULT_MAX_OUTPUT = 65536;

        const API_MODELS = {
            'gemini': [
                'gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.0-flash'
            ],
            'openai': [
                'gpt-5', 'gpt-5-mini', 'gpt-5-chat-latest', 'gpt-5-nano', 
                'gpt-4o', 'chatgpt-4o-latest', 'gpt-4o-mini', 
                'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano'
            ]
        };

        function loadApiKeyForProvider() {
            const provider = document.getElementById('apiProvider').value;
            const apiKeyStorageKey = `${provider}ApiKey`; // e.g., 'geminiApiKey' or 'openaiApiKey'
            
            document.getElementById('apiKey').value = localStorage.getItem(apiKeyStorageKey) || '';
        }

        function updateCharCounter(textareaId) {
            const textarea = document.getElementById(textareaId);
            const counter = document.getElementById(textareaId + 'Counter');
            if (textarea && counter) {
                // 숫자를 읽기 쉽게 3자리마다 콤마(,)를 추가합니다.
                const count = textarea.value.length.toLocaleString();
                counter.textContent = `${count}자`;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            if (history.scrollRestoration) {
                history.scrollRestoration = 'manual';
            }

            // 1. UI 요소 채우기
            updatePromptSelect();

            // 2. 설정 값 불러오기
            const savedProvider = localStorage.getItem('apiProvider') || 'gemini';
            const savedModel = localStorage.getItem('apiModel') || (savedProvider === 'openai' ? 'gpt-4o' : 'gemini-2.5-pro');
            const savedPrompt = localStorage.getItem('selectedPrompt') || 'default';

            // 3. UI에 설정 적용
            document.getElementById('apiProvider').value = savedProvider;
            handleProviderChange(); // 모델 목록 채우기 및 연결 테스트 실행
            
            const modelSelect = document.getElementById('apiModel');
            if (Array.from(modelSelect.options).some(opt => opt.value === savedModel)) {
                modelSelect.value = savedModel;
            }
            
            const promptSelect = document.getElementById('promptSelect');
            if (promptSelect.querySelector(`option[value="${savedPrompt}"]`)) {
                promptSelect.value = savedPrompt;
            }
            
            loadApiKeyForProvider();

            document.getElementById('sourceLanguage').value = localStorage.getItem('sourceLanguage') || 'chinese';
            document.getElementById('temperature').value = localStorage.getItem('temperature') || '1';
            document.getElementById('maxOutputTokens').value = localStorage.getItem('maxOutputTokens') || DEFAULT_MAX_OUTPUT;
            document.getElementById('topP').value = localStorage.getItem('topP') || '0.98';
            document.getElementById('topK').value = localStorage.getItem('topK') || '0';

            // 4. UI 업데이트 및 최종 작업
            loadSelectedPrompt();
            updateLanguageLabels();
            handleModelChange(modelSelect.value); // 여기서 한번 더 UI를 업데이트 해줍니다.
            
            // [수정] 중복 호출되던 연결 테스트 부분을 삭제했습니다.
            // handleProviderChange()가 이미 실행했기 때문에 필요 없습니다.

            // 5. 설정 저장 이벤트 리스너 연결
            const settingsToWatch = [
                'sourceLanguage', 'apiProvider', 'apiModel', 'apiKey', 'promptSelect',
                'temperature', 'maxOutputTokens', 'topP', 'topK'
            ];
            settingsToWatch.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', saveAllSettingsToStorage);
                }
            });
            const textareaIds = ['inputText', 'extractedChinese', 'translationResult', 'finalResult'];

            textareaIds.forEach(id => {
                const textarea = document.getElementById(id);
                if (textarea) {
                    // 페이지 로드 시 초기 글자 수 계산
                    updateCharCounter(id);

                    // 각 텍스트 영역에 입력 이벤트 리스너 추가
                    textarea.addEventListener('input', () => updateCharCounter(id));
                }
            });
        });

        function saveAllSettingsToStorage() {
            const provider = document.getElementById('apiProvider').value;
            const apiKeyStorageKey = `${provider}ApiKey`;

            // [수정] 제공자에 맞는 키 이름으로 API 키를 저장합니다.
            localStorage.setItem(apiKeyStorageKey, document.getElementById('apiKey').value);

            // 나머지 설정 저장
            localStorage.setItem('sourceLanguage', document.getElementById('sourceLanguage').value);
            localStorage.setItem('apiProvider', document.getElementById('apiProvider').value);
            localStorage.setItem('apiModel', document.getElementById('apiModel').value);
            localStorage.setItem('selectedPrompt', document.getElementById('promptSelect').value);
            
            localStorage.setItem('temperature', document.getElementById('temperature').value);
            localStorage.setItem('maxOutputTokens', document.getElementById('maxOutputTokens').value);
            localStorage.setItem('topP', document.getElementById('topP').value);
            localStorage.setItem('topK', document.getElementById('topK').value);
        }

        function toggleAdvancedSettings() {
            const panel = document.getElementById('advancedSettingsPanel');
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';
        }

        /**
         * @param {string} message - 표시할 메시지
         * @param {string} type - 'success', 'error', 'info' 또는 'persistent'
         * @param {boolean} forceClose - (persistent 전용) 강제로 닫을지 여부
         */
        function showToast(message, type = 'info', forceClose = false) {

            const persistentToast = document.getElementById('persistent-toast');
            if (type === 'persistent') {
                if (forceClose) {
                    persistentToast.classList.remove('show');
                } else {
                    persistentToast.textContent = message;
                    persistentToast.classList.add('show');
                }
                return;
            }

            const container = document.getElementById('toast-container');
            if (!container) return; 

            const toast = document.createElement('div');
            toast.className = `toast-notification ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);

            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 5000);
        }

        function toggleSpecialCharCheckButtonVisibility() {
            const translationResult = document.getElementById('translationResult').value;
            const validateBtn = document.getElementById('validateSpecialCharsBtn');
            if (validateBtn) {
                validateBtn.style.display = translationResult.trim() ? 'inline-block' : 'none';
            }
        }

        function clearInputText() {
            if (confirm("입력창의 모든 내용을 지우시겠습니까?")) {
                document.getElementById('inputText').value = '';
                updateReplaceButtonState();
                updateInputTextLabel(); 
                showToast('입력창을 비웠습니다.');
            }
        }
        
        function updateLanguageLabels() {
            const sourceLanguage = document.getElementById('sourceLanguage').value;
            const inputLabel = document.getElementById('input-text-label');
            const extractedLabel = document.getElementById('extracted-text-title');
            const punctuationBtn = document.getElementById('punctuationBtn');
            const languageType = document.getElementById('languageType');
            const extractBtn = document.getElementById('extractBtn'); 
            
            const targetLang = sourceLanguage === 'korean' ? '외국어' : '한국어';

            if (inputLabel) {
                inputLabel.textContent = `${labels[sourceLanguage]} → ${targetLang}`;
            }
            
            if (extractBtn) {
                
                extractBtn.innerHTML = `<i data-feather="mouse-pointer"></i> ${labels[sourceLanguage]} 추출`;
            }
            
            if (extractedLabel) {
                if (sourceLanguage === 'korean') {
                    extractedLabel.innerHTML = `<i data-feather="file-text"></i> 추출된 한국어`;
                } else {
                    extractedLabel.innerHTML = `<i data-feather="file-text"></i> 추출된 ${labels[sourceLanguage]}`;
                }
            }
            
            if (languageType) {
                languageType.textContent = labels[sourceLanguage];
            }

            if (sourceLanguage === 'chinese') {
                punctuationBtn.style.display = 'inline-block';
            } else {
                punctuationBtn.style.display = 'none';
            }
            
            feather.replace();
            updateInputTextLabel();
        }

        
        function updateExtractStats(count) {
            const extractCount = document.getElementById('extractCount');
            const extractStats = document.getElementById('extractStats');
            
            if (extractCount) {
                extractCount.textContent = count;
            }
            
            if (extractStats && count > 0) {
                extractStats.style.display = 'block';
            }
        }

        function updatePromptSelect() {
            const select = document.getElementById('promptSelect');
            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
            
            select.innerHTML = '<option value="default">기본 프롬프트</option>';
            
            for (const [name, prompt] of Object.entries(savedPrompts)) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            }
        }

        function loadSelectedPrompt() {
            const select = document.getElementById('promptSelect');
            const selectedPrompt = select.value;
            const sourceLanguage = document.getElementById('sourceLanguage').value;
            const promptTextarea = document.getElementById('translationPrompt');
            
            if (selectedPrompt === 'default') {
                promptTextarea.value = DEFAULT_PROMPTS[sourceLanguage] || DEFAULT_PROMPTS['chinese'];
            } else {
                const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
                promptTextarea.value = savedPrompts[selectedPrompt] || DEFAULT_PROMPTS[sourceLanguage];
            }
            
            localStorage.setItem('selectedPrompt', selectedPrompt);
        }

        function resetToDefault() {
            const sourceLanguage = document.getElementById('sourceLanguage').value;
            document.getElementById('translationPrompt').value = DEFAULT_PROMPTS[sourceLanguage] || DEFAULT_PROMPTS['chinese'];
            document.getElementById('promptSelect').value = 'default';
        }

        function savePrompt() {
            const name = document.getElementById('promptName').value.trim();
            const prompt = document.getElementById('translationPrompt').value;
            
            if (!name) {
                alert('프롬프트 이름을 입력해주세요.');
                return;
            }
            
            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
            savedPrompts[name] = prompt;
            localStorage.setItem('savedPrompts', JSON.stringify(savedPrompts));
            
            updatePromptSelect();
            document.getElementById('promptSelect').value = name;
            document.getElementById('promptName').value = ''; 
            showToast('프롬프트가 저장되었습니다.');
        }

        function exportPrompt() {
            const select = document.getElementById('promptSelect');
            const selectedName = select.value;

            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
            const promptToExport = savedPrompts[selectedName];

            if (!promptToExport) {
                alert('선택된 프롬프트를 찾을 수 없습니다.');
                return;
            }
            
            const dataStr = JSON.stringify({ name: selectedName, prompt: promptToExport }, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            
            linkElement.setAttribute('download', `EasyKr_prompt_${selectedName}.json`);
            linkElement.click();
        }

        function importPrompt() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            let { name, prompt } = data;

                            if (!name || !prompt) {
                                throw new Error('파일 형식이 올바르지 않습니다. "name"과 "prompt" 속성이 필요합니다.');
                            }

                            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
                            let newName = name;
                            let counter = 1;
                            
                            while (savedPrompts[newName]) {
                                newName = `${name} (${counter})`;
                                counter++;
                            }
                            
                            savedPrompts[newName] = prompt;
                            localStorage.setItem('savedPrompts', JSON.stringify(savedPrompts));

                            updatePromptSelect();
                            document.getElementById('promptSelect').value = newName;
                            loadSelectedPrompt(); 
                            
                            if (newName !== name) {
                                showToast(`'${name}' 프롬프트는 이미 존재하여 '${newName}'으로 저장했습니다.`, 'info');
                            } else {
                                showToast(`'${newName}' 프롬프트를 성공적으로 불러왔습니다.`, 'success');
                            }

                        } catch (error) {
                            alert(`프롬프트 파일을 읽는 중 오류가 발생했습니다: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function updateReplaceButtonState() {
            const inputText = document.getElementById('inputText').value;
            const translationResult = document.getElementById('translationResult').value;
            const replaceBtn = document.querySelector('button[onclick="replaceText()"]');
            
            
            replaceBtn.disabled = !(inputText.trim() && translationResult.trim());
        }

        function chunkArray(array, chunkSize) {
            const chunks = [];
            for (let i = 0; i < array.length; i += chunkSize) {
                chunks.push(array.slice(i, i + chunkSize));
            }
            return chunks;
        }

        function getGenerationConfig() {
            return {
                temperature: parseFloat(document.getElementById('temperature').value),
                maxOutputTokens: parseInt(document.getElementById('maxOutputTokens').value),
                topP: parseFloat(document.getElementById('topP').value),
                topK: parseInt(document.getElementById('topK').value),
            };
        }

        function handleModelChange(selectedModel) {
            const maxOutputTokensInput = document.getElementById('maxOutputTokens');
            const isLowSpec = LOW_SPEC_MODELS.hasOwnProperty(selectedModel);

            if (isLowSpec) {
                const spec = LOW_SPEC_MODELS[selectedModel];
                
                maxOutputTokensInput.value = spec.maxOutput;

                showToast(`'${selectedModel}'은 최대 출력이 ${spec.maxOutput} 토큰으로 제한됩니다. 번역 요청이 자동으로 분할됩니다.`, 'info');

            } else {
                const savedValue = localStorage.getItem('maxOutputTokens');
                maxOutputTokensInput.value = savedValue && !LOW_SPEC_MODELS.hasOwnProperty(localStorage.getItem('apiModel')) ? savedValue : DEFAULT_MAX_OUTPUT;
            }

            localStorage.setItem('apiModel', selectedModel);
            const statusElement = document.getElementById('connectionStatus');
            if (statusElement.classList.contains('status-connected')) {
                statusElement.textContent = `연결 성공 (${selectedModel})`;
            }

            updateApiSpecificParamsUI();
        }

        function updateApiSpecificParamsUI() {
            const apiProvider = document.getElementById('apiProvider').value;
            const selectedModel = document.getElementById('apiModel').value;

            const topKInput = document.getElementById('topK');
            const topKLabel = document.querySelector('label[for="topK"]');
            const topPInput = document.getElementById('topP');
            const topPLabel = document.querySelector('label[for="topP"]');

            // Top K 처리 (제공자 기준)
            if (apiProvider === 'openai') {
                topKInput.disabled = true;
                topKLabel.style.opacity = '0.5';
            } else {
                topKInput.disabled = false;
                topKLabel.style.opacity = '1';
            }

            // Top P 처리 (특정 모델 기준)
            if (apiProvider === 'openai' && OPENAI_MODELS_NO_TOP_P.includes(selectedModel)) {
                topPInput.disabled = true;
                topPLabel.style.opacity = '0.5';
            } else {
                topPInput.disabled = false;
                topPLabel.style.opacity = '1';
            }
        }

        function handleProviderChange() {
            const provider = document.getElementById('apiProvider').value;
            const modelSelect = document.getElementById('apiModel');
            const models = API_MODELS[provider] || [];

            modelSelect.innerHTML = '';

            models.forEach(modelName => {
                const option = document.createElement('option');
                option.value = modelName;
                option.textContent = modelName;
                modelSelect.appendChild(option);
            });

            if (models.length > 0) {
                modelSelect.value = models[0];
                handleModelChange(models[0]);
            }
            
            updateApiSpecificParamsUI(); // Top K 등 UI 업데이트
            loadApiKeyForProvider();     // 새 제공자에 맞는 API 키를 input에 불러오기

            if (document.getElementById('apiKey').value) {
                testConnection();
            } else {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = 'connection-status status-disconnected';
                statusElement.textContent = '연결되지 않음';
            }
        }

        function chunkLinesByCharLimit(lines, maxChars) {
            if (lines.join('\n').length <= maxChars) {
                return [lines];
            }

            const chunks = [];
            let currentChunk = [];
            let currentChars = 0;

            lines.forEach(line => {
                const lineLength = line.length + 1;

                if (lineLength > maxChars) {
                    if (currentChunk.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentChars = 0;
                    }
                    chunks.push([line]);
                    console.warn(`[번역 경고] 한 줄의 길이가 ${line.length}자로 너무 깁니다. 이 부분에서 번역 오류가 발생할 수 있습니다.`);
                    return;
                }

                if (currentChars + lineLength > maxChars) {
                    chunks.push(currentChunk);
                    currentChunk = [line];
                    currentChars = lineLength;
                } else {
                    currentChunk.push(line);
                    currentChars += lineLength;
                }
            });
            
            if (currentChunk.length > 0) {
                chunks.push(currentChunk);
            }

            return chunks;
        }

        async function translateText() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('apiModel').value;
            const prompt = document.getElementById('translationPrompt').value;
            const apiProvider = document.getElementById('apiProvider').value;

            if (!apiKey) {
                showToast('API 키를 입력해주세요.', 'error');
                return;
            }
            if (extractedChineseArray.length === 0) {
                const langName = labels[document.getElementById('sourceLanguage').value] || '외국어';
                showToast(`${langName}를 먼저 추출해주세요.`, 'info');
                return;
            }

            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const translationResultTextarea = document.getElementById('translationResult');
            
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            translationResultTextarea.value = '';
            translationResultTextarea.disabled = true;

            try {
                const promptLength = (prompt || '').length;
                let charLimit = 15000;
                if (LOW_SPEC_MODELS.hasOwnProperty(model)) {
                    charLimit = LOW_SPEC_MODELS[model].safeInputChars;
                }
                const effectiveCharLimit = charLimit - promptLength - 300;

                const chunks = chunkLinesByCharLimit(extractedChineseArray, effectiveCharLimit);
                const totalChunks = chunks.length;

                for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                    const chunkLines = chunks[chunkIndex];
                    const textToTranslate = chunkLines.join('\n');
                                        
                    if (totalChunks > 1) {
                        showToast(`번역 중... (${chunkIndex + 1}/${totalChunks}번째 요청)`, 'persistent');
                    } else {
                        showToast('번역 중...', 'persistent');
                    }
                    progressFill.style.width = `${((chunkIndex + 0.5) / totalChunks) * 100}%`;

                    let apiEndpoint = '';
                    let requestBody = {};
                    let requestHeaders = { 'Content-Type': 'application/json' };

                    if (apiProvider === 'openai') {
                        apiEndpoint = 'https://api.openai.com/v1/chat/completions';
                        requestHeaders['Authorization'] = `Bearer ${apiKey}`;
                        
                        requestBody = {
                            model: model,
                            messages: [
                                { role: 'system', content: prompt },
                                { role: 'user', content: textToTranslate }
                            ],
                            temperature: parseFloat(document.getElementById('temperature').value),
                        };

                        // [수정] top_p 파라미터를 조건부로 추가합니다.
                        if (!OPENAI_MODELS_NO_TOP_P.includes(model)) {
                            requestBody.top_p = parseFloat(document.getElementById('topP').value);
                        }

                        const modelsUsingNewParam = ['gpt-5', 'gpt-5-mini', 'gpt-5-chat', 'gpt-5-nano', 'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano'];
                        const maxTokensValue = parseInt(document.getElementById('maxOutputTokens').value);

                        if (modelsUsingNewParam.includes(model)) {
                            requestBody.max_completion_tokens = maxTokensValue;
                        } else {
                            requestBody.max_tokens = maxTokensValue;
                        }

                    } else {
                        apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                        const fullPrompt = prompt + '\n\n' + textToTranslate;
                        requestBody = {
                            contents: [{ parts: [{ text: fullPrompt }] }],
                            generationConfig: getGenerationConfig()
                        };
                    }

                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: requestHeaders,
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMessage = errorData.error?.message || response.statusText;
                        throw new Error(`API 오류 (요청 ${chunkIndex + 1}/${totalChunks}): ${errorMessage}`);
                    }

                    const data = await response.json();
                    
                    let translatedText = '';
                    if (apiProvider === 'openai') {
                        translatedText = data.choices?.[0]?.message?.content || '';
                    } else {
                        translatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    }
                    
                    translationResultTextarea.value += translatedText;
                    
                    if (chunkIndex < totalChunks - 1) {
                        translationResultTextarea.value += '\n';
                    }
                    translationResultTextarea.scrollTop = translationResultTextarea.scrollHeight;

                    progressFill.style.width = `${((chunkIndex + 1) / totalChunks) * 100}%`;
                }

                updateTranslationStatsFromTextarea();
                updateReplaceButtonState();
                
                setTimeout(() => { progressBar.style.display = 'none'; }, 1000);
                showToast('', 'persistent', true); 
                
                const finalPairCount = translationResultTextarea.value.split('\n').filter(line => line.includes('=')).length;
                showToast(`총 ${finalPairCount}개 항목이 번역되었습니다.`, 'success');
                toggleSpecialCharCheckButtonVisibility();

            } catch (error) {
                progressBar.style.display = 'none';
                showToast('', 'persistent', true);
                showToast(`${error.message}`, 'error');
                console.error(error);
            } finally {
                translationResultTextarea.disabled = false;
            }
        }

        function replaceText() {
            
            currentLogData = [];
            removeLogUI();

            const inputText = document.getElementById('inputText').value;
            const translationResultText = document.getElementById('translationResult').value;

            if (!inputText.trim()) {
                alert('변환할 내용이 있는 "입력 텍스트" 창을 먼저 채워주세요.');
                return;
            }
            
            if (translationResultText.trim()) {
                const hasBeenTranslatedViaApi = extractedChineseArray.length > 0; 
                if (!hasBeenTranslatedViaApi) {
                    if (!confirm('LLM 번역이 실행되지 않았습니다. 현재 "번역 결과" 창에 직접 입력된 내용으로 변환을 진행하시겠습니까?')) {
                        return;
                    } 
                }
            }

            if (!translationResultText.trim()) {
                alert('"번역 결과" 창이 비어있어 변환을 진행할 수 없습니다. 번역을 실행하거나, "원본=번역" 형식으로 내용을 직접 입력해주세요.');
                return;
            }
            
            const lines = translationResultText.split('\n');
            const allPairs = [];
            let ignoreFormatErrors = false; 
            let skippedLines = 0; 

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue; 

                const equalIndex = line.indexOf('=');
                const isInvalidPair = equalIndex === -1 || line.substring(equalIndex + 1).trim().length === 0;

                if (isInvalidPair) {
                    skippedLines++;
                    if (!ignoreFormatErrors) {
                        const proceed = confirm(
                            `오류: "번역 결과" 창의 ${i + 1}번째 줄 형식이 올바르지 않습니다.\n\n[내용]\n${line}\n\n"원본=번역" 형식이 아니거나 번역 내용이 비어있습니다. 이 줄과 이후의 모든 형식 오류를 무시하고 변환을 계속하시겠습니까?`
                        );

                        if (proceed) {
                            ignoreFormatErrors = true;
                            console.warn(`[일괄 변환 경고] 사용자가 형식 오류를 무시하기로 선택했습니다. ${i + 1}번째 줄을 건너뜁니다: "${line}"`);
                            continue;
                        } else {
                            showToast('형식 오류로 인해 변환이 중단되었습니다.', 'error');
                            return;
                        }
                    } else {
                        console.warn(`[일괄 변환 경고] 형식 오류가 있는 ${i + 1}번째 줄을 건너뜁니다: "${line}"`);
                        continue;
                    }
                } else { 
                    const original = line.substring(0, equalIndex);
                    const translation = line.substring(equalIndex + 1);
                    
                    allPairs.push({
                        original: original,
                        translation: translation,
                        length: original.length
                    });
                }
            }

            if (skippedLines > 0 && !ignoreFormatErrors) {
            } else if (skippedLines > 0 && ignoreFormatErrors) {
                showToast(`${skippedLines}개의 라인이 형식이 맞지 않아 변환에서 제외되었습니다.`, 'info');
            }

            if (allPairs.length === 0) {
                alert('변환에 사용할 유효한 번역 쌍을 찾지 못했습니다.');
                return;
            }

            // 길이를 기준으로 내림차순 정렬. 가장 긴 것부터 변환해야 중첩 오류 방지
            allPairs.sort((a, b) => b.length - a.length);
            
            let result = inputText;
            const processedRanges = []; // 변환된 영역을 기록할 배열
            let replacementCount = 0; 

            allPairs.forEach(pair => {
                let searchIndex = 0;
                
                while (true) {
                    const foundIndex = result.indexOf(pair.original, searchIndex);
                    if (foundIndex === -1) break;
                    
                    const foundEnd = foundIndex + pair.original.length;
                    
                    // 찾은 영역이 이전에 변환된 영역과 겹치는지 확인
                    const isOverlapping = processedRanges.some(range => 
                        (foundIndex < range.end && foundEnd > range.start)
                    );
                    
                    if (!isOverlapping) {
                        const before = result.substring(0, foundIndex);
                        const after = result.substring(foundEnd);
                        result = before + pair.translation + after;
                        
                        replacementCount++; 
                        currentLogData.push(`'${pair.original}' → '${pair.translation}'`); 

                        const lengthDiff = pair.translation.length - pair.original.length;
                        
                        // 변환된 영역 정보를 기록
                        processedRanges.push({
                            start: foundIndex,
                            end: foundIndex + pair.translation.length
                        });
                        
                        // 이후에 처리될 영역들의 위치를 바뀐 길이만큼 조정
                        processedRanges.forEach(range => {
                            if (range.start > foundIndex) {
                                range.start += lengthDiff;
                                range.end += lengthDiff;
                            }
                        });
                        
                        searchIndex = foundIndex + pair.translation.length;
                    } else {
                        searchIndex = foundIndex + 1;
                    }
                }
            });

            document.getElementById('finalResult').value = result;

            if (replacementCount > 0) {
                showToast(`${replacementCount}개 항목의 일괄 변환이 완료되었습니다.`, 'success');

                const finalResultText = document.getElementById('finalResult').value;
                const remainingChinese = finalResultText.match(/[\u4e00-\u9fff]+/g) || [];
                const pairsCount = allPairs.length;
                
                const targetContainer = document.getElementById('final-text-header');
                const remainingList = remainingChinese.length > 0
                    ? remainingChinese.map(c => `<code>"${c}"</code>`).join(', ')
                    : '없음';
                
                const summaryHTML = `
                    <div style="padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); font-size: 11px; color: #ccc;">
                        <p style="margin: 0 0 4px;"><strong>요약:</strong></p>
                        <p style="margin: 0 0 2px;">- 사용된 변환 쌍: ${pairsCount}개</p>
                        <p style="margin: 0 0 2px;">- 총 변환 횟수: ${replacementCount}회</p>
                        <p style="margin: 0;">- 미변환 중국어: ${remainingList}</p>
                    </div>
                `;
                
                const logListHTML = currentLogData.map((log, index) => {
                    const escapeHtml = (unsafe) => unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                    const parts = log.split('→');
                    const original = parts[0] ? escapeHtml(parts[0].trim()) : '';
                    const translated = parts[1] ? escapeHtml(parts[1].trim()) : '';
                    return `<p style="margin:0 0 2px;"><span style="color: #aaa; width: 2.5em; display: inline-block;">${index + 1}.</span>${original} <span style="color: #888;">→</span> <span style="color: #63e6be;">${translated}</span></p>`;
                }).join('');
                
                const logContentHTML = summaryHTML + logListHTML;

                setupLogButton(targetContainer, logContentHTML, '변환 로그 보기');

            } else {
                showToast('변환할 항목을 찾지 못했습니다.', 'info');
            }
            validateFinalText();
        }

        function copyToClipboard() {
            const finalResult = document.getElementById('finalResult').value;
            if (!finalResult) {
                showToast('복사할 내용이 없습니다.');
                return;
            }
            
            navigator.clipboard.writeText(finalResult).then(() => {
                showToast('클립보드에 복사되었습니다.');
            }).catch(() => {
                showToast('클립보드 복사에 실패했습니다.');
            });
        }

        function downloadResult() {
            const finalResult = document.getElementById('finalResult').value;
            if (!finalResult) {
                showToast('다운로드할 내용이 없습니다.');
                return;
            }
            
            const fileName = currentFileName ? `${currentFileName}_translated${currentFileExtension}` : 'translated_result.txt';
            const blob = new Blob([finalResult], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function saveSettings() {
            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');

const settings = {
                sourceLanguage: document.getElementById('sourceLanguage').value,
                apiProvider: document.getElementById('apiProvider').value,
                apiModel: document.getElementById('apiModel').value,

                // localStorage에서 각 제공자의 API 키를 직접 읽어와 저장합니다.
                geminiApiKey: localStorage.getItem('geminiApiKey') || '',
                openaiApiKey: localStorage.getItem('openaiApiKey') || '',

                translationPrompt: document.getElementById('translationPrompt').value,
                savedPrompts: savedPrompts,

                temperature: document.getElementById('temperature').value,
                maxOutputTokens: document.getElementById('maxOutputTokens').value,
                topP: document.getElementById('topP').value,
                topK: document.getElementById('topK').value,
            };

            const dataStr = JSON.stringify(settings, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = 'EasyKr_settings.json';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        function loadSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const settings = JSON.parse(e.target.result);
                            
                            document.getElementById('sourceLanguage').value = settings.sourceLanguage || 'chinese';
                            document.getElementById('apiProvider').value = settings.apiProvider || 'gemini';
                            document.getElementById('apiModel').value = settings.apiModel || 'gemini-2.5-pro';
                            // 'apiKey'를 직접 설정하는 대신, 아래 로직이 localStorage를 업데이트합니다.
                            
                            document.getElementById('translationPrompt').value = settings.translationPrompt || '';
                            
                            document.getElementById('temperature').value = settings.temperature || '1';
                            document.getElementById('maxOutputTokens').value = settings.maxOutputTokens || DEFAULT_MAX_OUTPUT;
                            document.getElementById('topP').value = settings.topP || '0.98';
                            document.getElementById('topK').value = settings.topK || '0';

                            // 파일에 있는 모든 설정을 localStorage에 저장합니다.
                            // 이렇게 하면 geminiApiKey와 openaiApiKey도 자동으로 저장됩니다.
                            for (const key in settings) {
                                if (Object.hasOwnProperty.call(settings, key)) {
                                    if (key === 'savedPrompts') {
                                        localStorage.setItem('savedPrompts', JSON.stringify(settings.savedPrompts));
                                    } else if (typeof settings[key] === 'string') {
                                        localStorage.setItem(key, settings[key]);
                                    }
                                }
                            }
                            
                            updatePromptSelect();
                            updateLanguageLabels();

                            // 제공자 변경 핸들러를 호출하여 모델 목록과 API 키 입력을 새로고침합니다.
                            handleProviderChange();
                            
                            showToast('설정이 성공적으로 불러와졌습니다!', 'success');
                        } catch (error) {
                            showToast('설정 파일을 읽는 중 오류가 발생했습니다.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }        
        
        function deletePrompt() {
            const select = document.getElementById('promptSelect');
            const selectedName = select.value;
            
            if (selectedName === 'default') {
                showToast('기본 프롬프트는 삭제할 수 없습니다.');
                return;
            }
            
            if (!confirm(`"${selectedName}" 프롬프트를 삭제하시겠습니까?`)) {
                return;
            }
            
            const savedPrompts = JSON.parse(localStorage.getItem('savedPrompts') || '{}');
            delete savedPrompts[selectedName];
            localStorage.setItem('savedPrompts', JSON.stringify(savedPrompts));
            
            updatePromptSelect();
            resetToDefault();
            showToast('프롬프트가 삭제되었습니다.');
        }
        
        function loadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) return;
            
            const fileName = file.name;
            const lastDotIndex = fileName.lastIndexOf('.');
            currentFileName = lastDotIndex !== -1 ? fileName.substring(0, lastDotIndex) : fileName;
            currentFileExtension = lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : '';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('inputText').value = e.target.result;
                showToast(`파일 "${fileName}"이 성공적으로 로드되었습니다.`);
                updateInputTextLabel();
                updateInputAnalysisViewer(); 
                updateCharCounter('inputText');
            };
            reader.readAsText(file, 'utf-8');
        }

        async function testConnection() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('apiModel').value;
            const apiProvider = document.getElementById('apiProvider').value; // 제공자 확인
            const statusElement = document.getElementById('connectionStatus');

            if (!apiKey) {
                showToast('API 키를 입력해주세요.');
                return;
            }

            statusElement.className = 'connection-status status-connecting';
            statusElement.textContent = '연결 중...';

            let apiEndpoint = '';
            let fetchOptions = {};

            if (apiProvider === 'openai') {
                // --- OpenAI 연결 테스트 로직 ---
                apiEndpoint = `https://api.openai.com/v1/models/${model}`;
                fetchOptions = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`, // OpenAI는 Bearer 토큰 인증 사용
                    }
                };
            } else { // 기본은 'gemini'
                // --- 기존 Gemini 연결 테스트 로직 ---
                let geminiModel = model;
                if (geminiModel.endsWith('-latest')) {
                    geminiModel = geminiModel.slice(0, -7);
                }
                apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}?key=${apiKey}`;
                fetchOptions = {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                };
            }

            try {
                const response = await fetch(apiEndpoint, fetchOptions);

                if (response.ok) {
                    const data = await response.json();
                    const displayName = data.displayName || data.id || model; // Gemini는 displayName, OpenAI는 id
                    statusElement.className = 'connection-status status-connected';
                    statusElement.textContent = `연결 성공 (${displayName})`;
                    showToast('API 연결에 성공했습니다!');
                } else {
                    const errorData = await response.json();
                    const errorMessage = errorData.error?.message || response.statusText;
                    throw new Error(`API 연결 실패: ${errorMessage}`);
                }
            } catch (error) {
                statusElement.className = 'connection-status status-disconnected';
                statusElement.textContent = '연결 실패';
                showToast(`API 연결에 실패했습니다. API 키, 모델명, 제공자를 확인해주세요.\n오류: ${error.message}`);
            }
        }

        function getLanguageRegex(language) {
            const patterns = {
                'english': /[가-힣\u4e00-\u9fff]*[a-zA-Z]+[가-힣\u4e00-\u9fffa-zA-Z\s,.!?;:'"()\-]*[a-zA-Z]*|[a-zA-Z]+[가-힣\u4e00-\u9fffa-zA-Z\s,.!?;:'"()\-]*|[a-zA-Z]{2,}/g,
                'japanese': /[가-힣\u4e00-\u9fff]*[\u3040-\u309f\u30a0-\u30ff]+[가-힣\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\s,.!?;:'"()\-]*[\u3040-\u309f\u30a0-\u30ff]*|[\u3040-\u309f\u30a0-\u30ff]+[가-힣\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\s,.!?;:'"()\-]*|[\u3040-\u309f\u30a0-\u30ff]{1,}/g,
                'korean': /[a-zA-Z\u4e00-\u9fff]*[가-힣]+[a-zA-Z\u4e00-\u9fff가-힣\s,.!?;:'"()\-]*[가-힣]*|[가-힣]+[a-zA-Z\u4e00-\u9fff가-힣\s,.!?;:'"()\-]*|[가-힣]{1,}/g
            };
            return patterns[language] || null; 
        }

        function extractLanguageSegments(text, language) {
            const results = [];
            
            if (language === 'chinese') {
                
                const stringLiteralRegex = /["'`]([^"'`]*[\u4e00-\u9fff][^"'`]*)["'`]/g;
                let match;
                
                while ((match = stringLiteralRegex.exec(text)) !== null) {
                    const content = match[1];
                    extractChineseSegments(content, results);
                }
                
                const commentRegex = /\/\*([^*]*[\u4e00-\u9fff][^*]*)\*\/|\/\/([^\n\r]*[\u4e00-\u9fff][^\n\r]*)/g;
                while ((match = commentRegex.exec(text)) !== null) {
                    const content = match[1] || match[2];
                    if (content) {
                        extractChineseSegments(content, results);
                    }
                }
                
                const htmlContentRegex = />([^<]*[\u4e00-\u9fff][^<]*)</g;
                while ((match = htmlContentRegex.exec(text)) !== null) {
                    const content = match[1];
                    extractChineseSegments(content, results);
                }
                
                const lines = text.split(/\n/);
                lines.forEach(line => {
                    if (!/^\s*(function|var|let|const|if|for|while|class|\}|\{|\/\/)/.test(line)) {
                        extractChineseSegments(line, results);
                    }
                });
                
                let uniqueResults = [...new Set(results)]
                    .filter(text => text.trim().length > 0)
                    .map(text => {
                        
                        return text.replace(/^[`'"'"'"「」『』（）【】〈〉《》〔〕〖〗]+|[`'"'"'"「」『』（）【】〈〉《》〔〕〖〗]+$/g, '');
                    })
                    .filter(text => text.length > 0);
                
                uniqueResults = [...new Set(uniqueResults)];
                return uniqueResults;

            } else {
                
                const languageRegex = getLanguageRegex(language);
                const matches = text.match(languageRegex);
                return matches ? [...new Set(matches)].filter(s => s.trim() !== '') : [];
            }
        }

        function extractChineseSegments(text, results) {
            if (!text) return;

            const longSegmentRegex = /[a-zA-Z0-9${}*]*[\u4e00-\u9fff][\u4e00-\u9fff\s\u3000-\u303f\uff00-\uffef。！？，、：；""「」『』（）【】〈〉《》〔〕〖〗""''…—～·\-_()\/\\&＆@*↔️➡️⬅️⬆️⬇️🔄📁💾🗑️✅📋✨🔧⚙️📝🇨🇳🇺🇸🇯🇵🇷🇺🇰🇷0-9a-zA-Z${}"`]*[\u4e00-\u9fff][a-zA-Z0-9${}*"`。]*/g;
            let longMatches = text.match(longSegmentRegex) || [];
            let extractedRanges = []; 

            longMatches.forEach(segment => {
                let cleaned = segment.trim();
                if (cleaned && /[\u4e00-\u9fff]/.test(cleaned)) {
                    results.push(cleaned);
                    
                    let startIndex = text.indexOf(segment);
                    if (startIndex !== -1) {
                        extractedRanges.push({
                            start: startIndex,
                            end: startIndex + segment.length,
                            text: segment
                        });
                    }
                }
            });

            const shortRegex = /[a-zA-Z0-9${}]*[\u4e00-\u9fff]+[a-zA-Z0-9${}]*(?:[。！？，])?/g;
            let match;
            
            while ((match = shortRegex.exec(text)) !== null) {
                let cleaned = match[0].trim();
                if (cleaned && /[\u4e00-\u9fff]/.test(cleaned) && cleaned.length >= 1) {
                    let matchStart = match.index;
                    let matchEnd = match.index + match[0].length;
                    
                    
                    let isOverlapping = extractedRanges.some(range => {
                        return (matchStart >= range.start && matchEnd <= range.end);
                    });
                    
                    
                    if (!isOverlapping) {
                        results.push(cleaned);
                    }
                }
            }
        }

        function handleInputTextChange() {
            updateReplaceButtonState();
            updateInputTextLabel();
            updateInputAnalysisViewer();
            updateCharCounter('inputText');
            
            document.querySelector('button[onclick="translateText()"]').disabled = true;
            
            const extractStats = document.getElementById('extractStats');
            if (extractStats.style.display === 'block') {
                if (!extractStats.innerHTML.includes('[원본이 수정되었습니다')) {
                    extractStats.innerHTML += ' <strong style="color: var(--text-status-connecting);">[원본이 수정되었습니다. 다시 추출해주세요!]</strong>';
                }
            }
        }

        function extractChinese() {
            const inputText = document.getElementById('inputText').value;
            const selectedLanguage = document.getElementById('sourceLanguage').value;

            const extractedChineseEl = document.getElementById('extractedChinese');
            const translationResultEl = document.getElementById('translationResult');
            const finalResultEl = document.getElementById('finalResult');

            if (!inputText.trim()) {
                showToast('입력 텍스트를 입력해주세요.');
                return;
            }

            if (extractedChineseEl.value || translationResultEl.value || finalResultEl.value) {
                if (!confirm("이미 작업 내용이 존재합니다. 추출을 다시 실행하면 아래 창의 내용이 모두 초기화됩니다. 계속하시겠습니까?")) {
                    return; 
                }
                
                extractedChineseEl.value = '';
                translationResultEl.value = '';
                finalResultEl.value = '';
                document.getElementById('extractStats').style.display = 'none';
                document.getElementById('translationStats').style.display = 'none';
                document.getElementById('validationResult').style.display = 'none';
                document.querySelector('button[onclick="translateText()"]').disabled = true;
                document.querySelector('button[onclick="replaceText()"]').disabled = true;
                removeLogUI(); 
                extractedChineseArray = [];
                translationPairs.clear();
            }
            
            const extractedResults = extractLanguageSegments(inputText, selectedLanguage);
            if (!extractedResults || extractedResults.length === 0) {
                const langName = labels[selectedLanguage] || '외국어';
                showToast(`해당 ${langName}가 발견되지 않았습니다.`);
                return;
            }

            extractedChineseArray = extractedResults;

            const joinedText = extractedChineseArray.join('');
            const chineseCharCount = (joinedText.match(/[\u4e00-\u9fff]/g) || []).length;
            
            extractedChineseEl.value = extractedChineseArray.join('\n');
            updateCharCounter('extractedChinese');
            
            const extractStats = document.getElementById('extractStats');
            const languageType = document.getElementById('languageType'); 
            
            extractStats.innerHTML = `<strong>추출 결과:</strong> <span id="languageType">${languageType.textContent}</span> ${chineseCharCount}자, <span id="extractCount">${extractedChineseArray.length}</span>개의 <span id="languageType">${languageType.textContent}</span> 문자열이 발견되었습니다.`;
            extractStats.style.display = 'block';

            if (extractedChineseArray.length > 0) {
                document.querySelector('button[onclick="translateText()"]').disabled = false;
            }
            
            const langName = (typeof labels !== 'undefined' && labels[selectedLanguage]) ? labels[selectedLanguage] : '외국어';
            showToast(`${extractedChineseArray.length}개의 ${langName} 문자열이 추출되었습니다.`);
        }

        function convertChinesePunctuation() {
            const inputText = document.getElementById('inputText').value;
            if (!inputText) {
                showToast('변환할 텍스트가 없습니다.');
                return;
            }
            
            const converted = inputText
                .replace(/。/g, '.')
                .replace(/！/g, '!')
                .replace(/？/g, '?')
                .replace(/（/g, '(')
                .replace(/）/g, ')')
                .replace(/：/g, ':')
                .replace(/；/g, ';')
                .replace(/、/g, ',');
            
            document.getElementById('inputText').value = converted;
            showToast('입력 텍스트의 중국어 문장부호가 변환되었습니다.');
        }
        
        function setTheme(button) {
            const themeName = button.getAttribute('data-theme');
            document.body.setAttribute('data-theme', themeName);
            localStorage.setItem('selectedTheme', themeName);

            document.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('active'));
            
            button.classList.add('active');
        }

        function applySavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme') || 'original-pink'; 
            document.body.setAttribute('data-theme', savedTheme);

            
            document.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('active'));
            
            const activeButton = document.querySelector(`.theme-button[data-theme="${savedTheme}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }
        
        function exportTranslationPairs() {
            const text = document.getElementById('translationResult').value;
            if (!text.trim()) {
                showToast('내보낼 내용이 없습니다.');
                return;
            }
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'EasyKr_pairs.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateInputTextLabel() {
            const inputText = document.getElementById('inputText').value;
            const label = document.getElementById('input-text-label');
            const sourceLanguage = document.getElementById('sourceLanguage').value;

            const labels = {
                'chinese': '중국어',
                'english': '영어',
                'japanese': '일본어',
                'korean': '한국어'
            };
            const sourceLangName = labels[sourceLanguage] || '외국어';
            const targetLangName = sourceLanguage === 'korean' ? '외국어' : '한국어';

            let newLabelText = `${sourceLangName} → ${targetLangName}`;
            
            if (inputText.trim() && sourceLanguage === 'chinese') {
                const chineseCharCount = (inputText.match(/[\u4e00-\u9fff]/g) || []).length;
                
                if (chineseCharCount > 0) {
                    
                    newLabelText = `${sourceLangName} (${chineseCharCount}자) → ${targetLangName}`;
                }
            }
            
            label.textContent = newLabelText;
        }

        function updateTranslationStatsFromTextarea() {
            const text = document.getElementById('translationResult').value;
            const statsDiv = document.getElementById('translationStats');
            const countSpan = document.getElementById('translationCount');

            if (!text.trim()) {
                statsDiv.style.display = 'none';
                return;
            }
            
            const pairCount = text.split('\n').filter(line => {
                const equalIndex = line.indexOf('=');
                return equalIndex !== -1 && line.substring(equalIndex + 1).trim().length > 0;
            }).length;


            if (pairCount > 0) {
                countSpan.textContent = pairCount;
                statsDiv.style.display = 'block';
            } else {
                statsDiv.style.display = 'none';
            }
        }

        function importTranslationPairs() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt,.json'; 
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const content = e.target.result;
                        let output = '';

                        if (file.name.toLowerCase().endsWith('.json')) {
                            try {
                                const jsonData = JSON.parse(content);
                                
                                for (const key in jsonData) {
                                    if (Object.hasOwnProperty.call(jsonData, key)) {
                                        output += `${key}=${jsonData[key]}\n`;
                                    }
                                }
                                showToast('JSON 파일을 "원본=번역" 형식으로 변환하여 불러왔습니다.');
                            } catch (error) {
                                showToast('JSON 파일 파싱에 실패했습니다. 파일 내용을 확인해주세요.\n오류: ' + error.message);
                                output = content; 
                            }
                        } else {
                            
                            output = content;
                            showToast('TXT 파일을 성공적으로 불러왔습니다.');
                        }
                        
                        document.getElementById('translationResult').value = output;
                        updateCharCounter('translationResult');
                        updateReplaceButtonState();
                        updateTranslationStatsFromTextarea();
                        toggleSpecialCharCheckButtonVisibility();
                    };
                    reader.readAsText(file, 'utf-8');
                }
            };
            input.click();
        }
        
        function validateFinalText() {
            const text = document.getElementById('finalResult').value;
            const resultDiv = document.getElementById('validationResult');
            if (!text.trim()) {
                resultDiv.style.display = 'none';
                return;
            }

            let results = [];
            let warnings = [];
            const lines = text.split('\n');

            const chineseChars = text.match(/[\u4e00-\u9fff]/g) || [];
            if (chineseChars.length > 0) {
                warnings.push(`잔여 중국어 ${chineseChars.length}자 발견: ${chineseChars.slice(0, 10).join('')}...`);
            } else {
                results.push(`잔여 중국어 없음`);
            }
            
            const stack = [];
            const pairs = { '(': ')', '{': '}', '[': ']', '"': '"', "'": "'" };
            let errorFound = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '\\' && j + 1 < line.length) {
                        j++;
                        continue;
                    }

                    if (Object.keys(pairs).includes(char)) {
                        
                        if (char === stack[stack.length - 1] && (char === '"' || char === "'")) {
                            
                            stack.pop();
                        } else {
                            stack.push(char);
                        }
                    } else if (Object.values(pairs).includes(char)) {
                        
                        if (pairs[stack[stack.length - 1]] === char) {
                            stack.pop();
                        } else {
                            warnings.push(`${i + 1}번째 줄: 닫는 괄호 짝이 맞지 않습니다. (<code>...${line.substring(Math.max(0, j-10), j+1)}...</code>)`);
                            errorFound = true;
                            break;
                        }
                    }
                }
                if (errorFound) break;
            }

            if (!errorFound) {
                if (stack.length > 0) {
                    warnings.push(`닫히지 않은 괄호/따옴표가 있습니다: ${stack.join(', ')}`);
                } else {
                    results.push('괄호 및 따옴표 짝이 모두 맞음');
                }
            }
            
            for (let i = 0; i < lines.length - 1; i++) {
                const currentLine = lines[i].trim();
                const nextLine = lines[i+1].trim();

                if ((currentLine.endsWith('}') || currentLine.endsWith(']') || currentLine.endsWith('"')) && nextLine.startsWith('"') && !currentLine.endsWith(',')) {
                    warnings.push(`${i + 1}번째 줄 끝: JSON 항목 사이에 쉼표(,)가 누락되었을 수 있습니다.`);
                }
            }
            
            let report = '<strong>검사 결과:</strong>';
            results.forEach(r => report += `<p style="display: flex; align-items: center; gap: 6px;"><i data-feather="check" class="text-status-connected"></i> ${r}</p>`);
            warnings.forEach(w => {
                report += `<p style="display: flex; align-items: start; gap: 6px;"><i data-feather="alert-triangle" class="text-status-disconnected" style="flex-shrink: 0; margin-top: 3px;"></i> <span>${w}</span></p>`;
            });

            if (warnings.length === 0) {
                report += '<p style="font-weight: bold; color: var(--text-status-connected); margin-top: 10px;">문제가 발견되지 않았습니다. (이 검사는 완벽하지 않으니 참고용으로만 사용하세요)</p>';
            }

            report += '<hr style="border: 0; border-top: 1px solid var(--border-main); margin: 12px 0 8px 0;">';
            report += '<p style="font-size: 12px; color: var(--text-subtitle); text-align: center; margin: 0;">자세한 사항은 패널 우측 상단의 로그를 참고하세요</p>';

            resultDiv.innerHTML = report;
            resultDiv.style.display = 'block';
            feather.replace();
        }
        
        function updateInputAnalysisViewer() { 
            const text = document.getElementById('inputText').value;
            const targetContainer = document.getElementById('input-text-header');

            removeLogUI(); 

            if (!text.trim()) return;
            
            const escapeHtml = (unsafe) => unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            
            const chineseRegex = /[\u4e00-\u9fff]/;
            const placeholderRegex = /{{\s*(.*?)\s*}}/g;
            const placeholderMatches = [...new Set(text.match(placeholderRegex) || [])];
            placeholderMatches.sort((a, b) => chineseRegex.test(b) - chineseRegex.test(a)); // 중국어 포함 항목을 위로

            let placeholderHtml = '';
            if (placeholderMatches.length > 0) {
                placeholderHtml += `
                    <div style="padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: #ccc;">
                        <p style="margin: 0 0 4px;"><strong>플레이스홀더 요약:</strong></p>
                        <p style="margin: 0;">총 <strong>${placeholderMatches.length}개</strong>의 고유한 플레이스홀더가 발견되었습니다.</p>
                    </div>
                `;
                placeholderMatches.forEach((item, index) => {
                    const truncatedItem = item.length > 50 ? escapeHtml(item.substring(0, 50)) + '...' : escapeHtml(item);
                    placeholderHtml += `<p style="margin:0 0 2px;"><span style="color: #aaa; width: 2.5em; display: inline-block;">${index + 1}.</span><code>${truncatedItem}</code></p>`;
                });
            }

            const varRegex = /(?:const|let|var)\s+([a-zA-Z0-9_$]*[\u4e00-\u9fff]+[a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
            const varMatches = [...new Set(Array.from(text.matchAll(varRegex), m => m[1] || m[2]))];
            varMatches.sort((a, b) => chineseRegex.test(b) - chineseRegex.test(a)); // 중국어 포함 항목을 위로

            let varHtml = '';
            if (varMatches.length > 0) {
                varHtml += `
                    <div style="padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: #ccc;">
                        <p style="margin: 0 0 4px;"><strong>JS 변수 선언 요약:</strong></p>
                        <p style="margin: 0;">총 <strong>${varMatches.length}개</strong>의 고유한 변수가 선언되었습니다.</p>
                    </div>
                `;
                varMatches.forEach((item, index) => {
                    varHtml += `<p style="margin:0 0 2px;"><span style="color: #aaa; width: 2.5em; display: inline-block;">${index + 1}.</span><code>${escapeHtml(item)}</code></p>`;
                });
            }

            let finalLogContent = '';
            if (placeholderHtml) {
                finalLogContent += placeholderHtml;
            }
            if (varHtml) {
                if (placeholderHtml) { 
                    finalLogContent += '<hr style="border: 0; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 12px 0;">';
                }
                finalLogContent += varHtml;
            }
            
            if (finalLogContent) {
                setupLogButton(targetContainer, finalLogContent, '입력 텍스트 분석 보기');
            }
        }
        
        function setupLogButton(targetContainer, logContentHTML, logTitle = '변환 로그 보기') {
            if (!targetContainer || !logContentHTML) return;

            const existingBtn = targetContainer.querySelector('.btn-log-viewer');
            const existingPopover = targetContainer.querySelector('.log-popover');
            if (existingBtn) existingBtn.remove();
            if (existingPopover) existingPopover.remove();
            
            const popover = document.createElement('div');
            popover.className = 'log-popover';
            popover.innerHTML = logContentHTML;
            
            const button = document.createElement('button');
            button.className = 'btn-log-viewer';
            button.title = logTitle;
            button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`;
            
            targetContainer.appendChild(button);
            targetContainer.appendChild(popover);
            feather.replace();
            
            const handleOutsideClick = (event) => {
                if (!button.contains(event.target) && !popover.contains(event.target)) {
                    popover.classList.remove('visible');
                    document.removeEventListener('click', handleOutsideClick);
                }
            };
            
            button.addEventListener('click', (event) => {
                event.stopPropagation(); 
                const isVisible = popover.classList.toggle('visible');
                
                if (isVisible) {
                    document.addEventListener('click', handleOutsideClick);
                } else {
                    document.removeEventListener('click', handleOutsideClick);
                }
            });

        }

        function removeLogUI() {
            const existingBtn = document.querySelector('.btn-log-viewer');
            const existingPopover = document.querySelector('.log-popover');
            if (existingBtn) existingBtn.remove();
            if (existingPopover) existingPopover.remove();
        }

                function getCharCounts(charArray) {
            return charArray.reduce((acc, char) => {
                acc[char] = (acc[char] || 0) + 1;
                return acc;
            }, {});
        }

        function validateSpecialCharacters() {
            const text = document.getElementById('translationResult').value;
            if (!text.trim()) {
                showToast('검사할 번역 결과가 없습니다.', 'info');
                return;
            }

            const specialCharRegex = /[^\p{L}\p{N}\s]/gu;
            
            const lines = text.split('\n');
            const mismatches = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim() || !line.includes('=')) continue;

                const equalIndex = line.indexOf('=');
                const original = line.substring(0, equalIndex);
                const translated = line.substring(equalIndex + 1);

                const originalChars = original.match(specialCharRegex) || [];
                const translatedChars = translated.match(specialCharRegex) || [];

                if (originalChars.length !== translatedChars.length) {
                    mismatches.push({ lineNum: i + 1, original, translated, originalChars, translatedChars });
                    continue;
                }

                const originalCounts = getCharCounts(originalChars);
                const translatedCounts = getCharCounts(translatedChars);

                let isMatch = true;
                for (const char in originalCounts) {
                    if (originalCounts[char] !== translatedCounts[char]) {
                        isMatch = false;
                        break;
                    }
                }

                if (isMatch) {
                    for (const char in translatedCounts) {
                        if (translatedCounts[char] !== originalCounts[char]) {
                            isMatch = false;
                            break;
                        }
                    }
                }

                if (!isMatch) {
                    mismatches.push({ lineNum: i + 1, original, translated, originalChars, translatedChars });
                }
            }

            const countOccurrences = (str, sub) => str.split(sub).length - 1;

            const specialChars = ['{', '}', '[', ']', '(', ')', '"', '"', '"', "'", "'", "'", '`', '<', '>', '\\', '{{', '}}', '|', '*', '_', '~', '^', '%', '$', '#', '@'];

            mismatches.sort((a, b) => {
                const aHasMismatch = specialChars.some(char => 
                    countOccurrences(a.original, char) !== countOccurrences(a.translated, char)
                );
                
                const bHasMismatch = specialChars.some(char => 
                    countOccurrences(b.original, char) !== countOccurrences(b.translated, char)
                );

                if (aHasMismatch && !bHasMismatch) return -1;
                if (!aHasMismatch && bHasMismatch) return 1;
                return 0;
            });

            const targetContainer = document.getElementById('translation-result-header');

            if (mismatches.length > 0) {
                showToast(`검사 완료: ${mismatches.length}개의 라인에서 특수문자 불일치가 발견되었습니다.`, 'error');

                let logContentHTML = `
                    <div style="padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: #ccc; overflow: hidden;">
                        <div style="float: left;">
                            <p style="margin: 0 0 4px;"><strong>검사 요약:</strong></p>
                            <p style="margin: 0;">총 ${lines.filter(l => l.includes('=')).length}줄 중 <strong id="mismatch-count" style="color: #f0a7a7;">${mismatches.length}</strong> 라인에서 불일치가 발견되었습니다.</p>
                        </div>
                        <div style="float: left; font-size: 11px; margin-top: 5px;">
                            <label-checkbox style="cursor: pointer; display: flex; align-items: center; gap: 4px;">
                                <input type="checkbox" id="hide-comma-mismatch-checkbox" onchange="filterLogView()">
                                쉼표 개수만 다른 경우 숨기기
                            </label>
                        </div>
                    </div>
                `;
                
                mismatches.forEach(item => {
                    const originalCounts = getCharCounts(item.originalChars);
                    const translatedCounts = getCharCounts(item.translatedChars);
                    
                    const tempOriginalCounts = { ...originalCounts };
                    const tempTranslatedCounts = { ...translatedCounts };
                    delete tempOriginalCounts[','];
                    delete tempOriginalCounts['，'];
                    delete tempTranslatedCounts[','];
                    delete tempTranslatedCounts['，'];

                    const isCommaOnlyMismatch = JSON.stringify(tempOriginalCounts) === JSON.stringify(tempTranslatedCounts);

                    const escapeHtml = (unsafe) => unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                    const originalCharsStr = item.originalChars.map(c => `<code>${escapeHtml(c)}</code>`).join(' ');
                    const translatedCharsStr = item.translatedChars.map(c => `<code>${escapeHtml(c)}</code>`).join(' ');

                    logContentHTML += `
                        <div class="log-mismatch-item" ${isCommaOnlyMismatch ? 'data-is-comma-only="true"' : ''} style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.08);">
                            <p style="color: #aaa; font-weight: bold; margin: 0 0 5px;">Line ${item.lineNum}:</p>
                            <p style="margin: 0 0 2px;"><span style="color:#888;">원본:</span> <code>${escapeHtml(item.original)}</code></p>
                            <p style="margin: 0 0 8px;"><span style="color:#888;">번역:</span> <code style="color: #63e6be;">${escapeHtml(item.translated)}</code></p>
                            <p style="margin: 0 0 2px; font-size: 11px; color: #f0a7a7;"><strong style="color: #aaa;">불일치 상세:</strong></p>
                            <p style="margin: 0 0 2px; font-size: 11px; color: #ddd;">- 원본 특수문자 (${item.originalChars.length}개): ${originalCharsStr || '없음'}</p>
                            <p style="margin: 0; font-size: 11px; color: #ddd;">- 번역 특수문자 (${item.translatedChars.length}개): ${translatedCharsStr || '없음'}</p>
                        </div>
                    `;
                });
                setupLogButton(targetContainer, logContentHTML, '특수문자 검사 로그 보기');
            } else {
                const existingBtn = targetContainer.querySelector('.btn-log-viewer');
                if (existingBtn) existingBtn.remove();
                const existingPopover = targetContainer.querySelector('.log-popover');
                if (existingPopover) existingPopover.remove();

                showToast('검사 완료: 모든 특수문자가 일치합니다!', 'success');
            }
        }

        function filterLogView() {
            const checkbox = document.getElementById('hide-comma-mismatch-checkbox');
            const items = document.querySelectorAll('.log-mismatch-item');
            let visibleMismatches = 0;

            items.forEach(item => {
                const isCommaOnly = item.getAttribute('data-is-comma-only') === 'true';
                if (checkbox.checked && isCommaOnly) {
                    item.style.display = 'none';
                } else {
                    item.style.display = 'block';
                    visibleMismatches++;
                }
            });

            const countElement = document.getElementById('mismatch-count');
            if (countElement) {
                countElement.textContent = visibleMismatches;
            }
        }

        function toggleUpdateLog(event) {
            event.stopPropagation();
            const popover = document.getElementById('update-log-popover');
            const isVisible = popover.classList.toggle('visible');

            const handleOutsideClick = (e) => {
                if (!popover.contains(e.target)) {
                    popover.classList.remove('visible');
                    document.removeEventListener('click', handleOutsideClick);
                }
            };
            
            if (isVisible) {
                // 다른 팝오버는 닫기
                const otherPopovers = document.querySelectorAll('.log-popover.visible');
                otherPopovers.forEach(p => {
                    if(p.id !== 'update-log-popover') p.classList.remove('visible');
                });
                document.addEventListener('click', handleOutsideClick);
            } else {
                document.removeEventListener('click', handleOutsideClick);
            }
        }

        applySavedTheme(); 
        feather.replace(); 
    </script>
</body>
</html>
